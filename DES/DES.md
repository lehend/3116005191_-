



《网络信息安全》

DES实验报告



学院：  计算机科学学院        
专业：  信息安全          班级  二    
学号：3116005191                    
姓名：罗方泓                         
 











DES算法总的说来可以两部分组成：
一、对密钥的处理。这一部分是把我们用的64位密钥（实际用的56位，去掉了8个奇偶校验位）分散成16个48位的子密钥。
二、对数据的加密。通过第一步生成的子密钥来加密我们所要加密的数据，最终生成密文。


一．密钥分散——子密钥的生成
64比特的密钥生成16个48比特的子密钥。其生成过程见图：
64比特的密钥K，经过PC-1后，生成56比特的串。其下标如表所示：

该比特串分为长度相等的比特串C0和D0（分别为28比特）。然后C0和D0分别循环左移1位，得到C1和D1。C1和D1合并起来生成C1D1。C1D1经过PC-2变换后即生成48比特的K1。K1的下标列表为：
PC-2	14	17	11	24	1	5	3	28
	15	6	21	10	23	19	12	4
	26	8	16	7	27	20	13	2
	41	52	31	37	47	55	30	40
	51	45	33	48	44	49	39	56
	34	53	46	42	50	36	29	32

C1、D1分别循环左移LS2位，再合并，经过PC-2，生成子密钥K2……依次类推直至生成子密钥K16。
注意：Lsi (I =1,2,….16)的数值是不同的。具体见下表：

 
二．      DES算法加密过程
对DES算法加密过程图示的说明如下：待加密的64比特明文串m，经过IP置换后，得到的比特串的下标列表如下：

该比特串被分为32位的L0和32位的R0两部分。R0子密钥K1经过变换f(R0,K1)（f变换算法见下）输出32位的比特串f1,f1与L0做异或运算。

f1与L0做异或运算后的结果赋给R1，R0则原封不动的赋给L1。L1与R0又做与以上完全相同的运算，生成L2，R2…… 一共经过16次运算。最后生成R16和L16。其中R16为L15与f(R15,K16)做不进位二进制加法运算的结果，L16是R15的直接赋值。 
R16与L16合并成64位的比特串。值得注意的是R16一定要排在L16前面。R16与L16合并后成的比特串，经过置换IP-1后所得比特串的下标列表如下：


IP-1	40	8	48	16	56	24	64	32
	39	7	47	15	55	23	63	31
	38	6	46	14	54	22	62	30
	37	5	45	13	53	21	61	29
	36	4	44	12	52	20	60	28
	35	3	43	11	51	19	59	27
	34	2	42	10	50	18	58	26
	33	1	41	9	49	17	57	25

经过置换IP-1后生成的比特串就是密文e.。
 
f 算法
变换f(Ri-1,Ki)的功能是将32比特的输入再转化为32比特的输出。其过程如图所示：

 
 
首先、输入Ri-1(32比特)经过变换E后，膨胀为48比特。膨胀后的比特串的下标列表如下：
 
其次、膨胀后的E和Ki异或的结果分为8组，每组6比特。各组经过各自的S盒后，变为4比特，

S盒的算法为：输入b1,b2,b3,b4,b5,b6，计算x=b1*2+b6, y=b5+b4*2+b3*4+b2*8，再从Si表（见下表）中查出x 行，y 列的值Sxy。将Sxy化为二进制，即得Si盒的输出。
S1:
　　14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,
　　0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,
　　4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,
　　15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,
S2:
　　15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,
　　3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,
　　0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,
　　13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,
S3:
　　10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,
　　13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,
　　13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,
　　1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,
S4:
　　7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,
　　13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,
　　10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,
　　3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,
S5:
　　2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,
　　14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,
　　4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,
　　11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,
S6:
　　12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,
　　10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,
　　9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,
　　4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,
S7:
　　4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,
　　13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,
　　1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,
　　6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,
S8:
　　13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,
　　1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,
　　7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,
　　2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11,
 
最后、合并8组S盒输出成为32比特。该32比特经过P变换后，其下标列表如下：
 

 
经过P变换后输出的比特串才是32比特的f (Ri-1,Ki)。
 
以上介绍了DES算法的加密过程。DES算法的解密过程是一样的，区别仅仅在于第一次迭代时用子密钥K16，第二次K15、......，最后一次用K1，算法本身并没有任何变化。




代码：
#include<stdio.h>
#include<string.h>
#include <conio.h> 

typedef unsigned __int64 MYTYPE;

MYTYPE key=0x123456;
MYTYPE i_key[16];

void produce_key()
{
   
   int cp_1[56]=
   {
	   57,49,41,33,25,17,9, 
       1,58,50,42,34,26,18, 
       10,2,59,51,43,35,27, 
       19,11,3,60,50,44,36,
       65,55,47,39,31,23,15, 
       7,62,54,46,38,30,22, 
       14,6,61,53,45,37,29, 
       21,13,5,28,20,12,4 
   };
   int cp_2[48]=
   {
	   14,17,11,24,1,5,3,28, 
       15,6,21,10,23,19,12,4, 
       26,8,16,7,27,20,13,2, 
       41,52,31,37,47,55,30,40, 
       51,45,33,48,44,49,39,56, 
       34,53,46,42,50,36,29,32 
   };

   int lsi[16]={1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1};
   MYTYPE c=0,d=0;
   
   int i,j;

   for(i=0;i<28;i++){
	   c=c<<1|(key&((MYTYPE)1<<cp_1[i]))>>cp_1[i];
   }
   for(;i<56;i++){
	   d=d<<1|(key&((MYTYPE)1<<cp_1[i]))>>cp_1[i];
   }
   for(i=0;i<16;i++){
	   c=(c<<lsi[i]|c>>(28-lsi[i]))&0xfffffff;
	   d=(d<<lsi[i]|d>>(28-lsi[i]))&0xfffffff;
	   MYTYPE t=c<<28|d;
	   i_key[i]=0;
	   for(j=0;j<48;j++){
		   i_key[i]=i_key[i]<<1|(t&((MYTYPE)1<<cp_2[j]))>>cp_2[j];
	   }
   }

}

MYTYPE fun(MYTYPE r, MYTYPE k)
{
	int E[48]=
	{
		32,1,2,3,4,5,4,5,6,7,8,9,8,9,10,11,
        12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21,
        22,23,24,25,24,25,26,27,28,29,28,29,30,31,32,1
	};
	int P[32]=
	{
        16,7,20,21,29,12,28,17, 1,15,23,26, 5,18,31,10,
        2,8,24,14,32,27, 3, 9,19,13,30, 6,22,11, 4,25
	};
	int S[8][64]=
	{
        14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,
        0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,
        4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,
        15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,

        15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,
        3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,
        0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,
        13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,

        10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,
        13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,
        13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,
        1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,

        7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,
        13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,
        10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,
        3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,

        2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,
        14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,
        4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,
        11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3, 

        12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,
        10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,
        9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,
        4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,

        4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,
        13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,
        1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,
        6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,

        13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,
        1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,
        7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,
        2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11
		       
	};

	int i;
	MYTYPE temp=0,ret=0;
	for(i=0;i<48;i++){
	   temp=temp<<1|(r&((MYTYPE)1<<E[i]))>>E[i];
    }
	temp^=k;
	for(i=0;i<8;i++){
		ret<<=4;
		MYTYPE t=(temp&0x3f0000000000)>>40;
		ret|=S[i][((t>>5)<<1|t&0x1)<<4|(t<<1)>>2];
		temp<<=6;
	}
	temp=0;
	for(i=0;i<32;i++){
	   temp=temp<<1|(ret&(1<<P[i]))>>P[i];
    }

	return temp;

}
    
MYTYPE encrypt(MYTYPE ptext)
{
	int ip[64]=
	{
		58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,
        62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,
        57,49,41,33,25,17, 9,1,59,51,43,35,27,19,11,3,
        61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7
	};
	int rip[64]=
	{
		40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,
        38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,
        36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,
        34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25
	};

    int i;
	MYTYPE l=0,r=0;
	for(i=0;i<32;i++){
	   l=l<<1|(ptext&((MYTYPE)1<<(64-ip[i])))>>(64-ip[i]);///!!!
   }
   for(;i<64;i++){
	   r=r<<1|(ptext&((MYTYPE)1<<(64-ip[i])))>>(64-ip[i]);;
   }
   //printf("\nl=%I64x  r=%I64x\n",l,r);
	for(i=0;i<16;i++){
		MYTYPE f=fun(r,i_key[i]),t=l;
		l=r;
		r=t^f;
	}
    r=r<<32|l;
	MYTYPE ctext=0;
    for(i=0;i<64;i++){
		ctext=ctext<<1|(r&((MYTYPE)1<<(64-rip[i])))>>(64-rip[i]);
	}
	return ctext;

}

MYTYPE decrypt(MYTYPE ctext)
{
	int ip[64]=
	{
		58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,
        62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,
        57,49,41,33,25,17, 9,1,59,51,43,35,27,19,11,3,
        61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7
	};
	int rip[64]=
	{
		40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,
        38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,
        36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,
        34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25
	};

    int i;
	MYTYPE l=0,r=0;
	for(i=0;i<32;i++){
	   r=r<<1|(ctext&((MYTYPE)1<<(64-ip[i])))>>(64-ip[i]);
    }
   for(;i<64;i++){
	   l=l<<1|(ctext&((MYTYPE)1<<(64-ip[i])))>>(64-ip[i]);
   }
   for(i=15;i>=0;i--){
		MYTYPE f,t=r;
		r=l;
		f=fun(r,i_key[i]);
		l=t^f;
	}
    l=l<<32|r;
	MYTYPE ptext=0;
    for(i=0;i<64;i++){
		ptext=ptext<<1|(l&((MYTYPE)1<<(64-rip[i])))>>(64-rip[i]);
	}
	return ptext;
}

void en_char(const char *src, const char *dst)
{
	MYTYPE ptext;
	int i;
	wchar_t str[10000];

	freopen(dst,"w",stdout);
    freopen(src,"r",stdin);	
    while(wscanf(L"%S",str)!=0){  
		int k=0,len=-1;
		len=(strlen((char*)str)+1)/2;
		//while((str[++len]&0xff)!=0);
		str[len]='  ';	    
		str[len+1]=0;
    //wprintf(L"%S",str);
	while(1){
       ptext=0;
	   for(i=0;i<4&&k<=len;i++,k++){ 
		  // printf("%c",*str);		   
          ptext<<=16;
	      ptext|=str[k];
	   }
	   if(i)  printf("%I64u ",encrypt(ptext));
	   if(k==len+1) break;
	}
	}
}

void de_char(const char *dst)
{
	MYTYPE ctext;
	wchar_t ptext[5];
	ptext[4]='\0';
	freopen(dst,"r",stdin);
    
	while(scanf("%I64u",&ctext)!=EOF){
		ctext=decrypt(ctext);
		int i=4;
		while(ctext){
           ptext[--i]=(wchar_t)ctext;
		//printf("(%I64u)",ctext);t&0xffff;
		   ctext>>=16;
		}
		wprintf(L"%S",ptext+i);
	}

}

void get_key()
{
	        char c;
	        int count=0;
	        key=0;
	        while(1){
	           c=getch();
	           if(c==13||count==20) break;
			   if(c==8&&count){putchar(8); putchar(' '); putchar(8); key/=10; count--;}
	           if(c>='0'&&c<='9'){putchar('*'); key=key*10+c-'0'; count++;}
			}
}

int main(int argc, char *argv[])
{
 		
        char src[20],dst[20]="output.txt";
    
		if(strcmp(argv[0],"encrypt")==0){
			if(argc==1) {
				printf("the source file name: "); scanf("%s",src);
                printf("the dest file name: "); scanf("%s",dst);
			}
			else if(argc==2) 
				strcpy(src,argv[1]);			
			else if(argc==3) {
				strcpy(dst,argv[2]);
				strcpy(src,argv[1]);
			}
			printf("the key: ");
			
			get_key();
            produce_key();
			en_char(src,dst);
		}
		else if(strcmp(argv[0],"decrypt")==0){
			if(argc==1) {
				printf("the source file name: "); scanf("%s",dst);
			}
			else if(argc==2){
                strcpy(dst,argv[1]);
			}
			printf("the key: ");

			get_key();
			produce_key();
            printf("\nthe result:\n");
			de_char(dst);
		}

	return 0;
}